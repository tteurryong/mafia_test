<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ì‹±ê¸€ ë§ˆí”¼ì•„ - </title>
<style>
  :root { --bg:#121212; --card:#222; --btn:#444; --accent:#ffc107; --alive:#28a745; --dead:#6c757d; color-scheme: dark; }
  body { margin:0; font-family: 'Malgun Gothic',sans-serif; background:var(--bg); color:#eee; padding:18px; display:flex; justify-content:center; }
  #wrap { width:100%; max-width:900px; }
  header { display:flex; justify-content:space-between; align-items:center; gap:12px; }
  h1 { margin:0; font-size:20px; }
  #scoreboard { position:fixed; right:16px; top:16px; background:var(--card); padding:10px; border-radius:8px; min-width:160px; box-shadow:0 6px 18px rgba(0,0,0,0.6); }
  #scoreboard h3 { margin:0 0 8px 0; font-size:14px; text-align:center; }
  #scoreList { font-size:13px; line-height:1.6; }
  #game { background:transparent; margin-top:12px; }
  #controls { background:var(--card); padding:12px; border-radius:8px; display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
  select, button { background:var(--btn); color:#eee; border:none; padding:8px 10px; border-radius:6px; cursor:pointer; }
  button:hover { filter:brightness(1.1); }
  #main { display:flex; gap:12px; margin-top:12px; }
  #left { flex:1; }
  #messages { background:var(--card); padding:12px; border-radius:8px; min-height:280px; max-height:560px; overflow:auto; white-space:pre-wrap; font-size:14px; }
  #players { margin-top:10px; display:flex; flex-wrap:wrap; gap:8px; }
  .player { background:#333; padding:8px 12px; border-radius:8px; min-width:70px; text-align:center; }
  .alive { background:var(--alive); color:#051205; }
  .dead { background:var(--dead); color:#ddd; text-decoration:line-through; }
  .you { outline:3px solid rgba(255,193,7,0.12); }
  #right { width:300px; }
  #inputSection { margin-top:12px; background:var(--card); padding:10px; border-radius:8px; min-height:120px; }
  .small { font-size:13px; color:#ccc; }
  .roleBadge { display:inline-block; padding:4px 8px; border-radius:999px; background:#444; font-size:12px; margin-left:8px; }
  #reveal { background:linear-gradient(90deg,#2b2b2b,#1a1a1a); padding:12px; border-radius:8px; margin-top:10px; }
  .muted { color:#bdbdbd; font-size:13px; }
</style>
</head>
<body>
<div id="wrap">
  <header>
    <h1>ì‹±ê¸€ ë§ˆí”¼ì•„ â€” </h1>
    <div class="muted">í”Œë ˆì´ì–´ëŠ” 1ë²ˆ. ë°¤/ë‚® ì§„í–‰ Â· ê²½ì°° ì§ì ‘ ì¡°ì‚¬ Â· ì˜ì‚¬ ì œí•œ ì¹˜ìœ </div>
  </header>

  <div id="scoreboard">
    <h3>ì ìˆ˜íŒ</h3>
    <div id="scoreList">-</div>
  </div>

  <div id="game">
    <div id="controls">
      ì°¸ê°€ ì¸ì›:
      <select id="playerCount"></select>
      <button id="startBtn">ê²Œì„ ì‹œì‘</button>
      <button id="autoFillBtn">í…ŒìŠ¤íŠ¸ìš© ë¹ ë¥¸ì‹œì‘(7ëª…)</button>
      <div class="small">(ê²½ì°°: ì„ íƒ ì¡°ì‚¬ / ì˜ì‚¬: ê²½ì°° ë˜ëŠ” 'ì¡°ì‚¬ëœ ë¬´ì£„ì'ë§Œ ì¹˜ë£Œ)</div>
    </div>

    <div id="main">
      <div id="left">
        <div id="messages"></div>
        <div id="players"></div>
        <div id="inputSection"></div>
      </div>

      <div id="right">
        <div id="reveal" style="display:none">
          <strong>ì¢…í•© ê²°ê³¼</strong>
          <div id="revealList"></div>
        </div>
        <div style="margin-top:10px" class="small">ê²Œì„ ë„ì›€ë§: ë°¤ì— ì—­í•  í–‰ë™, ë‚®ì— íˆ¬í‘œ(ë‹¤ìˆ˜ê²°) â€” ê²½ì°°ì´ ë§ˆí”¼ì•„ë¼ ë°œí‘œí•˜ë©´ ì‹œë¯¼ì€ ìë™ íˆ¬í‘œí•©ë‹ˆë‹¤.</div>
      </div>
    </div>
  </div>
</div>

<script>
/* ---- ì´ˆê¸° ì„¸íŒ… ---- */
const playerCountSelect = document.getElementById('playerCount');
for(let i=3;i<=12;i++){ const o=document.createElement('option'); o.value=i; o.textContent=i+'ëª…'; playerCountSelect.appendChild(o); }
const startBtn = document.getElementById('startBtn');
const autoFillBtn = document.getElementById('autoFillBtn');
const messages = document.getElementById('messages');
const playersDiv = document.getElementById('players');
const inputSection = document.getElementById('inputSection');
const revealBox = document.getElementById('reveal');
const revealList = document.getElementById('revealList');
const scoreList = document.getElementById('scoreList');

/* ì ìˆ˜ ê´€ë¦¬ (ëŸ°íƒ€ì„) */
let scores = {}; // key: player id (number) -> score
function ensureScores(n){
  for(let i=0;i<n;i++) if(scores[i]===undefined) scores[i]=0;
  renderScores();
}
function renderScores(){
  let html='';
  for(const [id,sc] of Object.entries(scores)){
    html += `í”Œë ˆì´ì–´ ${parseInt(id)+1}: ${sc}ì <br/>`;
  }
  scoreList.innerHTML = html || '-';
}

/* ê²Œì„ ìƒíƒœ */
let gameState = null;

/* ì—­í• ë°°ì • */
function rolesByCount(n){
  let mafiaCount = Math.max(1, Math.floor(n/4));
  let roles = [];
  for(let i=0;i<mafiaCount;i++) roles.push('ë§ˆí”¼ì•„');
  if(n>=6){ roles.push('ì˜ì‚¬'); roles.push('ê²½ì°°'); }
  while(roles.length < n) roles.push('ì‹œë¯¼');
  // shuffle
  for(let i=roles.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [roles[i],roles[j]] = [roles[j],roles[i]];
  }
  return roles;
}

/* ë¡œê¹… */
function log(msg, clear=false){
  if(clear) messages.textContent='';
  messages.textContent += msg + '\n';
  messages.scrollTop = messages.scrollHeight;
}

/* ë Œë” í”Œë ˆì´ì–´ UI */
function renderPlayers(){
  playersDiv.innerHTML='';
  gameState.players.forEach(p=>{
    const d=document.createElement('div');
    d.className='player '+(p.alive? 'alive':'dead') + (p.id===0? ' you':'');
    d.textContent = (p.id+1) + (p.id===0? ' (ë‹¹ì‹ )':'');
    // show role badge for debugging? Hidden unless reveal.
    playersDiv.appendChild(d);
  });
}

/* í—¬í¼: ì‚´ì•„ìˆëŠ” ë°°ì—´ */
function alivePlayers(){ return gameState.players.filter(p=>p.alive); }

/* ì‹œì‘ */
startBtn.onclick = ()=> startGame(parseInt(playerCountSelect.value));
autoFillBtn.onclick = ()=> { playerCountSelect.value = 7; startGame(7); };

/* startGame */
function startGame(n){
  const roles = rolesByCount(n);
  gameState = {
    players: roles.map((r,i)=>({id:i, role:r, alive:true})),
    day:0,
    night:0,
    policeInvestigated: new Set(), // ids that have been investigated
    policeReports: {}, // id -> boolean isMafia
    nightActions: { mafiaKill:null, doctorSave:null, policeCheck:null },
    firstNight:true,
    forcedVoteTarget:null, // if police revealed mafia -> citizens must vote this id
  };
  // initialize scores for players
  ensureScores(n);
  log('ê²Œì„ ì‹œì‘! í”Œë ˆì´ì–´ëŠ” 1ë²ˆì…ë‹ˆë‹¤.', true);
  // FIRST NIGHT: tell mafia who each other are (only to mafia players)
  const mafiaIds = gameState.players.filter(p=>p.role==='ë§ˆí”¼ì•„').map(p=>p.id);
  if(mafiaIds.length>1){
    // if player(1ë²ˆ) is mafia, tell them
    if(gameState.players[0].role==='ë§ˆí”¼ì•„'){
      log(`(ë¹„ë°€) ë‹¹ì‹ ì€ ë§ˆí”¼ì•„ì…ë‹ˆë‹¤. ë§ˆí”¼ì•„ ë™ë£Œ: ${mafiaIds.filter(id=>id!==0).map(x=>x+1).join(', ')}ë²ˆ`);
    }
    // AI mafia implicitly know their teammates (no UI)
  } else {
    if(gameState.players[0].role==='ë§ˆí”¼ì•„'){
      log('(ë¹„ë°€) ë‹¹ì‹ ì€ í˜¼ì ë§ˆí”¼ì•„ì…ë‹ˆë‹¤.');
    }
  }
  renderPlayers();
  setTimeout(()=> nextPhase('night'), 900);
}

/* phase ì „í™˜ */
function nextPhase(phase){
  inputSection.innerHTML='';
  if(phase==='night') nightPhase();
  else if(phase==='day') dayPhase();
  else if(phase==='vote') {} // handled inside dayPhase/aiVote
  else if(phase==='end') endPhase();
}

/* NIGHT */
function nightPhase(){
  gameState.night++;
  gameState.nightActions = { mafiaKill:null, doctorSave:null, policeCheck:null };
  gameState.policeReportThisNight = null;
  gameState.forcedVoteTarget = null;
  log(`\nğŸŒ™ ë°¤ ${gameState.night}ì¼ì°¨ ì‹œì‘`);
  renderPlayers();

  // if player dead -> no night action for player; AI proceed
  if(!gameState.players[0].alive){
    log('ë‹¹ì‹ ì€ ì£½ì—ˆìŠµë‹ˆë‹¤. ë°¤ í–‰ë™ ì—†ìŒ.');
    setTimeout(()=> aiNightActions(), 800);
    return;
  }

  // If player role choose accordingly
  const me = gameState.players[0];
  if(me.role === 'ë§ˆí”¼ì•„'){
    log('ë‹¹ì‹ (ë§ˆí”¼ì•„)ì€ ì£½ì¼ ëŒ€ìƒ ì„ íƒí•˜ì„¸ìš”:');
    mafiaChooseTarget();
  } else if(me.role === 'ì˜ì‚¬'){
    log('ë‹¹ì‹ (ì˜ì‚¬)ì€ ì‚´ë¦´ ëŒ€ìƒ ì„ íƒí•˜ì„¸ìš” (ê²½ì°° ë˜ëŠ” "ì¡°ì‚¬ëœ ë¬´ì£„ì" ìš°ì„ , ì—†ìœ¼ë©´ ìì‹  ë˜ëŠ” ê²½ì°° ê°€ëŠ¥):');
    doctorChooseTarget();
  } else if(me.role === 'ê²½ì°°'){
    log('ë‹¹ì‹ (ê²½ì°°)ì€ ì¡°ì‚¬í•  ëŒ€ìƒì„ ì„ íƒí•˜ì„¸ìš” (ë³¸ì¸ ì œì™¸):');
    policeChooseTarget();
  } else {
    log('ë‹¹ì‹ (ì‹œë¯¼)ì€ ë°¤ì— í•  ì¼ì´ ì—†ìŠµë‹ˆë‹¤.');
    setTimeout(()=> aiNightActions(), 800);
  }
}

/* ìœ í‹¸: ë²„íŠ¼ ìƒì„± */
function mkBtn(text, onClick){
  const b = document.createElement('button');
  b.textContent = text;
  b.onclick = onClick;
  return b;
}

/* ë§ˆí”¼ì•„ ëŒ€ìƒ ì„ íƒ(í”Œë ˆì´ì–´) */
function mafiaChooseTarget(){
  inputSection.innerHTML='';
  const targets = alivePlayers().filter(p=>p.role !== 'ë§ˆí”¼ì•„');
  targets.forEach(p=>{
    const b = mkBtn((p.id+1)+'ë²ˆ', ()=>{
      gameState.nightActions.mafiaKill = p.id;
      inputSection.innerHTML='';
      log(`ë‹¹ì‹ (ë§ˆí”¼ì•„)ì€ ${p.id+1}ë²ˆì„ ê³µê²© ëŒ€ìƒìœ¼ë¡œ ì„ íƒí–ˆìŠµë‹ˆë‹¤.`);
      setTimeout(()=> aiNightActions(), 600);
    });
    inputSection.appendChild(b);
  });
}

/* ì˜ì‚¬ ì„ íƒ(í”Œë ˆì´ì–´) - ì œí•œ ê·œì¹™ ë°˜ì˜ */
function doctorChooseTarget(){
  inputSection.innerHTML='';
  const me = gameState.players[0];
  // allowed list: police OR any id that has been investigated and found NOT mafia
  const allowed = new Set();
  // police id(s)
  const policeIds = gameState.players.filter(p=>p.role==='ê²½ì°°').map(p=>p.id);
  policeIds.forEach(id=>allowed.add(id));
  // investigated not mafia:
  for(const [idStr,isMafia] of Object.entries(gameState.policeReports || {})){
    const id = parseInt(idStr);
    if(isMafia === false) allowed.add(id);
  }
  // always allow self and police
  allowed.add(me.id);
  // build list
  const candidates = alivePlayers().filter(p=> allowed.has(p.id));
  if(candidates.length === 0){
    // fallback: allow self only
    const b = mkBtn((me.id+1)+'ë²ˆ (ìê¸° ìì‹ )', ()=>{
      gameState.nightActions.doctorSave = me.id;
      inputSection.innerHTML='';
      log(`ì˜ì‚¬ê°€ ìì‹ ì„ ì¹˜ë£Œí•˜ê¸°ë¡œ ì„ íƒí–ˆìŠµë‹ˆë‹¤.`);
      setTimeout(()=> aiNightActions(), 600);
    });
    inputSection.appendChild(b);
    return;
  }
  candidates.forEach(p=>{
    const b = mkBtn((p.id+1)+'ë²ˆ', ()=>{
      gameState.nightActions.doctorSave = p.id;
      inputSection.innerHTML='';
      log(`ì˜ì‚¬ê°€ ${p.id+1}ë²ˆì„ ì¹˜ë£Œ ëŒ€ìƒìœ¼ë¡œ ì„ íƒí–ˆìŠµë‹ˆë‹¤.`);
      setTimeout(()=> aiNightActions(), 600);
    });
    inputSection.appendChild(b);
  });
}

/* ê²½ì°° ì„ íƒ(í”Œë ˆì´ì–´) */
function policeChooseTarget(){
  inputSection.innerHTML='';
  const targets = alivePlayers().filter(p=>p.id !== 0 && !gameState.policeInvestigated.has(p.id));
  // if none left uninvestigated, allow previously investigated (as fallback)
  const fallback = alivePlayers().filter(p=>p.id !== 0);
  const list = targets.length ? targets : fallback;
  list.forEach(p=>{
    const b = mkBtn((p.id+1)+'ë²ˆ', ()=>{
      gameState.nightActions.policeCheck = p.id;
      inputSection.innerHTML='';
      log(`ê²½ì°°ì´ ${p.id+1}ë²ˆì„ ì¡°ì‚¬ ëŒ€ìƒìœ¼ë¡œ ì„ íƒí–ˆìŠµë‹ˆë‹¤.`);
      setTimeout(()=> aiNightActions(), 600);
    });
    inputSection.appendChild(b);
  });
}

/* AI ë°¤ í–‰ë™ (ê²½ì°° AI prefers non-investigated) */
function aiNightActions(){
  const alive = alivePlayers();

  // mafia AI choose if none selected by player (and if there are AI mafia)
  if(gameState.nightActions.mafiaKill === null){
    const mafiaAI = alive.filter(p=>p.role==='ë§ˆí”¼ì•„' && p.id !== 0);
    if(mafiaAI.length > 0){
      const targets = alive.filter(p=>p.role!=='ë§ˆí”¼ì•„');
      if(targets.length>0){
        const target = targets[Math.floor(Math.random()*targets.length)];
        gameState.nightActions.mafiaKill = target.id;
        log(`AI ë§ˆí”¼ì•„ê°€ ${target.id+1}ë²ˆì„ ê³µê²© ëŒ€ìƒìœ¼ë¡œ ì„ íƒí–ˆìŠµë‹ˆë‹¤.`);
      }
    }
  }

  // doctor AI
  if(gameState.nightActions.doctorSave === null){
    const doctorAI = alive.filter(p=>p.role==='ì˜ì‚¬' && p.id !== 0);
    if(doctorAI.length > 0){
      // choose police if alive, or choose a previously 'investigated not mafia' if exists, else self or random alive
      const policeIds = gameState.players.filter(p=>p.role==='ê²½ì°°' && p.alive).map(p=>p.id);
      const investigatedNot = Object.entries(gameState.policeReports || {}).filter(([k,v])=>v===false).map(([k,v])=>parseInt(k)).filter(id=> gameState.players[id].alive);
      let choice = null;
      if(policeIds.length>0) choice = policeIds[Math.floor(Math.random()*policeIds.length)];
      else if(investigatedNot.length>0) choice = investigatedNot[Math.floor(Math.random()*investigatedNot.length)];
      else choice = doctorAI[0].id; // heal self
      gameState.nightActions.doctorSave = choice;
      log(`AI ì˜ì‚¬ê°€ ${choice+1}ë²ˆì„ ì¹˜ë£Œ ëŒ€ìƒìœ¼ë¡œ ì„ íƒí–ˆìŠµë‹ˆë‹¤.`);
    }
  }

  // police AI: prefer not-yet-investigated
  if(gameState.nightActions.policeCheck === null){
    const policeAI = alive.filter(p=>p.role==='ê²½ì°°' && p.id !== 0);
    if(policeAI.length > 0){
      // choose uninvestigated among alive non-player first
      const candidates = alive.filter(p=>p.id !== 0 && !gameState.policeInvestigated.has(p.id));
      const pool = candidates.length ? candidates : alive.filter(p=>p.id !== 0);
      if(pool.length>0){
        const choice = pool[Math.floor(Math.random()*pool.length)];
        gameState.nightActions.policeCheck = choice.id;
        log(`AI ê²½ì°°ì´ ${choice.id+1}ë²ˆì„ ì¡°ì‚¬ ëŒ€ìƒìœ¼ë¡œ ì„ íƒí–ˆìŠµë‹ˆë‹¤.`);
      }
    }
  }

  setTimeout(resolveNightActions, 900);
}

/* resolve night actions */
function resolveNightActions(){
  const { mafiaKill, doctorSave, policeCheck } = gameState.nightActions;
  // mafia kill vs doctor save
  if(mafiaKill !== null){
    if(mafiaKill !== doctorSave){
      gameState.players[mafiaKill].alive = false;
      log(`\në°¤ì— ${mafiaKill+1}ë²ˆ í”Œë ˆì´ì–´ê°€ ì£½ì—ˆìŠµë‹ˆë‹¤.`);
    } else {
      log(`\nì˜ì‚¬ê°€ ${doctorSave+1}ë²ˆ í”Œë ˆì´ì–´ë¥¼ ì¹˜ë£Œí•˜ì—¬ ìƒì¡´í–ˆìŠµë‹ˆë‹¤.`);
    }
  } else {
    log('\në§ˆí”¼ì•„ê°€ ì´ë²ˆ ë°¤ì—ëŠ” ê³µê²©í•˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
  }

  // police check -> store report (revealed next morning)
  if(policeCheck !== null){
    const isMafia = gameState.players[policeCheck].role === 'ë§ˆí”¼ì•„';
    gameState.policeReports[policeCheck] = isMafia;
    gameState.policeInvestigated.add(policeCheck);
    // keep a "night-report" to be displayed next morning
    gameState.policeReportThisNight = { target: policeCheck, isMafia };
    log(`ê²½ì°°ì´ ${policeCheck+1}ë²ˆì„ ì¡°ì‚¬í–ˆìŠµë‹ˆë‹¤. (ê²°ê³¼ëŠ” ì•„ì¹¨ì— ê³µê°œë©ë‹ˆë‹¤.)`);
  } else {
    gameState.policeReportThisNight = null;
  }

  renderPlayers();

  // If player died, auto proceed
  if(!gameState.players[0].alive){
    log('\në‹¹ì‹ ì´ ì‚¬ë§í–ˆìŠµë‹ˆë‹¤. ê²Œì„ì´ ìë™ ì§„í–‰ë©ë‹ˆë‹¤.');
    setTimeout(()=> nextPhase('day'), 900);
    return;
  }

  if(checkWin()){
    setTimeout(()=> nextPhase('end'), 900);
  } else {
    setTimeout(()=> nextPhase('day'), 900);
  }
}

/* DAY */
function dayPhase(){
  gameState.day++;
  log(`\nâ˜€ ë‚® ${gameState.day}ì¼ì°¨ ì‹œì‘`);
  // reveal police result from last night (if any)
  if(gameState.policeReportThisNight){
    const { target, isMafia } = gameState.policeReportThisNight;
    log(`ê²½ì°° ì¡°ì‚¬ ê²°ê³¼ ê³µê°œ: ${target+1}ë²ˆì€ ${isMafia ? 'ë§ˆí”¼ì•„ì…ë‹ˆë‹¤!' : 'ë§ˆí”¼ì•„ê°€ ì•„ë‹™ë‹ˆë‹¤.'}`);
    // if isMafia true -> force all citizens to vote that target
    if(isMafia){
      gameState.forcedVoteTarget = target;
      log(`ê²½ì°°ì˜ ì¡°ì‚¬ë¡œ ${target+1}ë²ˆì´ ë§ˆí”¼ì•„ë¡œ íŒì •ë˜ì—ˆìŠµë‹ˆë‹¤. ëª¨ë“  ì‹œë¯¼ì€ ì´ëŒ€ìƒì— íˆ¬í‘œí•©ë‹ˆë‹¤.`);
    } else {
      gameState.forcedVoteTarget = null;
    }
  } else {
    gameState.forcedVoteTarget = null;
  }

  renderPlayers();

  if(!gameState.players[0].alive){
    log('ë‹¹ì‹ ì€ ì£½ì–´ì„œ íˆ¬í‘œì— ì°¸ì—¬í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. AIê°€ íˆ¬í‘œë¥¼ ì§„í–‰í•©ë‹ˆë‹¤.');
    setTimeout(()=> aiVote(null), 900);
  } else {
    // If forcedVoteTarget exists and player is citizen (not mafia), auto-vote for target
    if(gameState.forcedVoteTarget !== null && gameState.players[0].role !== 'ë§ˆí”¼ì•„'){
      log(`ë‹¹ì‹ ì€ ì‹œë¯¼ì´ë¯€ë¡œ ìë™ìœ¼ë¡œ ${gameState.forcedVoteTarget+1}ë²ˆì—ê²Œ íˆ¬í‘œí•©ë‹ˆë‹¤.`);
      setTimeout(()=> aiVote(gameState.forcedVoteTarget), 800);
    } else {
      setupVoteUI();
    }
  }
}

/* setup vote UI (player chooses unless forced) */
function setupVoteUI(){
  inputSection.innerHTML = '<div class="small">íˆ¬í‘œ: ì²˜í˜•í•  ì‚¬ëŒì„ ì„ íƒí•˜ì„¸ìš” (ë³¸ì¸ ì œì™¸). ë‹¤ìˆ˜ê²°, ë™ì ì´ë©´ ì²˜í˜• ì—†ìŒ.</div>';
  const alive = alivePlayers().filter(p=>p.id!==0);
  alive.forEach(p=>{
    const b = mkBtn((p.id+1)+'ë²ˆ', ()=> {
      inputSection.innerHTML='';
      log(`ë‹¹ì‹ ì€ ${p.id+1}ë²ˆì„ íˆ¬í‘œí–ˆìŠµë‹ˆë‹¤.`);
      setTimeout(()=> aiVote(p.id), 600);
    });
    inputSection.appendChild(b);
  });
}

/* AI Vote & tally
   playerVoted: number (id) or null if player didn't vote (dead or auto handled)
*/
function aiVote(playerVoted=null){
  const votes = {}; // id -> count
  function add(id){ votes[id]= (votes[id]||0)+1; }

  // If forcedVoteTarget present: all citizens (non-mafia) -> vote for it
  const forced = gameState.forcedVoteTarget;

  // Player vote
  if(playerVoted !== null){
    add(playerVoted);
  }

  // AI players (exclude player id 0)
  const ais = alivePlayers().filter(p=>p.id !== 0);
  ais.forEach(ai=>{
    // If forced and this ai is citizen/role != mafia -> must vote for forced target
    if(forced !== null && ai.role !== 'ë§ˆí”¼ì•„'){
      add(forced);
      return;
    }
    // AI vote logic
    const candidates = alivePlayers().filter(x=> x.id !== ai.id);
    if(ai.role === 'ë§ˆí”¼ì•„'){
      // vote non-mafia preferentially
      const non = candidates.filter(x=> x.role !== 'ë§ˆí”¼ì•„');
      const choice = non.length ? non[Math.floor(Math.random()*non.length)] : candidates[Math.floor(Math.random()*candidates.length)];
      add(choice.id);
    } else {
      // citizen-like: random
      const choice = candidates[Math.floor(Math.random()*candidates.length)];
      add(choice.id);
    }
  });

  // Show vote counts
  log('\níˆ¬í‘œ ê²°ê³¼:');
  for(const [id,count] of Object.entries(votes)){
    log(`${parseInt(id)+1}ë²ˆ: ${count}í‘œ`);
  }

  // determine max
  let max = 0;
  let winners = [];
  for(const [id,count] of Object.entries(votes)){
    if(count>max){ max=count; winners=[parseInt(id)]; }
    else if(count===max){ winners.push(parseInt(id)); }
  }

  if(winners.length===1){
    const executed = winners[0];
    // executed could be undefined if votes empty -> but at least some votes exist
    // execute only if max>0
    if(max>0){
      gameState.players[executed].alive=false;
      log(`\n${executed+1}ë²ˆ í”Œë ˆì´ì–´ê°€ ì²˜í˜•ë˜ì—ˆìŠµë‹ˆë‹¤.`);
    } else {
      log('\níˆ¬í‘œê°€ ë¬´íš¨(í‘œ ì—†ìŒ). ì²˜í˜• ì—†ìŒ.');
    }
  } else {
    log('\níˆ¬í‘œ ë™ì ìœ¼ë¡œ ì²˜í˜•ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
  }

  renderPlayers();

  // If player died due to vote, handle automatic
  if(!gameState.players[0].alive){
    log('\në‹¹ì‹ ì´ ì²˜í˜•ë˜ì–´ ê²Œì„ ìë™ ì§„í–‰ë©ë‹ˆë‹¤.');
    setTimeout(()=> {
      if(checkWin()) nextPhase('end'); else nextPhase('night');
    }, 900);
    return;
  }

  if(checkWin()){
    setTimeout(()=> nextPhase('end'), 900);
  } else {
    setTimeout(()=> nextPhase('night'), 900);
  }
}

/* ìŠ¹ë¦¬ ì¡°ê±´ */
function checkWin(){
  const alive = alivePlayers();
  const mafiaAlive = alive.filter(p=>p.role==='ë§ˆí”¼ì•„').length;
  const others = alive.length - mafiaAlive;
  if(mafiaAlive === 0){
    log('\nğŸ‰ ì‹œë¯¼íŒ€ ìŠ¹ë¦¬! ëª¨ë“  ë§ˆí”¼ì•„ ì œê±°!');
    // update scores: citizens +10, mafia -2
    applyScores('citizen');
    return true;
  }
  if(mafiaAlive >= others){
    log('\nğŸ’€ ë§ˆí”¼ì•„íŒ€ ìŠ¹ë¦¬! ë§ˆí”¼ì•„ê°€ ë™ìˆ˜ ì´ìƒì…ë‹ˆë‹¤.');
    applyScores('mafia');
    return true;
  }
  return false;
}

/* ìŠ¤ì½”ì–´ ì ìš©
   winnersTeam: 'citizen' or 'mafia'
*/
function applyScores(winnersTeam){
  gameState.players.forEach(p=>{
    const team = (p.role==='ë§ˆí”¼ì•„') ? 'mafia' : 'citizen';
    if(team === winnersTeam) scores[p.id] = (scores[p.id]||0) + 10;
    else scores[p.id] = (scores[p.id]||0) - 2;
  });
  renderScores();
}

/* ì¢…ë£Œ ì²˜ë¦¬: ì—­í•  ê³µê°œ & ê²°ê³¼ ì°½ */
function endPhase(){
  log('\n=== ê²Œì„ ì¢…ë£Œ: ì—­í•  ê³µê°œ ===');
  let html = '';
  gameState.players.forEach(p=>{
    html += `${p.id+1}ë²ˆ: ${p.role} (${p.alive ? 'ìƒì¡´':'ì‚¬ë§'})<br/>`;
  });
  revealBox.style.display='block';
  revealList.innerHTML = html;
  inputSection.innerHTML = '<div style="text-align:center;margin-top:10px;"><button id="restart">ë‹¤ì‹œ ì‹œì‘</button></div>';
  document.getElementById('restart').onclick = ()=> location.reload();
  renderPlayers();
}

/* ì´ˆê¸°: ë¹ˆì ìˆ˜ */
renderScores();

/* ---- ìœ í‹¸ ë ---- */
</script>
</body>
</html>
